<pre>
-------------------- Week – 1: CREATION OF TABLES --------------------

EMPLOYEE TABLE
SQL> create table employee (empno number,ename varchar2(10), job varchar2(10),mgr number,sal number);

a.Add a column commission with domain to the Employee table
SQL> alter table employee add(commission number);
b. Insert any five records into the table.
SQL>insert into employee values(101,’abhi’,’manager’,1234,10000,’70’)
SQL>insert into employee values(102,’rohith’,’analyst’,2345,9000,’65’)
c. Update the column details of job
SQL> update employee set job=’trainee’ where empno=103; 1 row updated.
SQL> select * from employee;
d.Rename the column of Employ table using alter command.
SQL> alter table employee rename column mgr to manager_no;

DEPARTMENT TABLE
SQL> create table department(deptno number,deptname varchar2(10),location varchar2(10))

a. Add column designation to the department table
SQL> alter table department add(designation varchar2(10));
b. Insert values into the table.
SQL> insert into department values(9,’accounting’,’hyderabad’,’manager’);
c. List the records of dept table grouped by deptno.
SQL> select deptno,deptname from department group by deptno,deptname;
d. Update the record where deptno is 9.
SQL> update department set designation=’accountant’ where deptno=9;
e. Delete any column data from the table.
SQL> alter table department drop(designation);

CUSTOMER TABLE
SQL> create table customer(custname varchar2(20),custstreet varchar2(20),custcity varchar2(20)); 

a.) Insert values into the table.
SQL> insert into customer values(‘nithin’,balaji colony ,’hyd’);
b.) Add salary column to the table.
SQL> alter table customer add(salary number);
C.)Alter the table column domain.  
SQL> alter table customer rename column salary to income; 
d.)Drop salary column of the customer table.  
SQL> alter table customer drop column income;
e.)Delete the rows of customer table whose custcityis ‘hyd’  
SQL> delete from customer where custcity=’hyd’;

BRANCH TABLE
SQL> create table branch(branchname varchar2(20),branchcity varchar2(20),asserts number); 

a.) Increase the size of data type for asserts to the branch.  
SQL> alter table branch modify asserts varchar2(20);
b.) Add and drop a column to the branch table.   
SQL> alter table branch add (branchstreet varchar2(20);
SQL> alter table branch drop column branchstreet;
C.) Insert values to the table
SQL> insert into branch values(‘balaji’,’tirupati’ ,21)
d.) Update the branch name column   
SQL> alter table branch rename column branchname to name;
e.) Delete any two columns from the table.  
SQL> alter table branch drop column branchcity;

SAILOR TABLE
SQL> create table sailor(sid number,sname varchar2(20),rating varchar2(20));

a. ) Add column age to the sailor table. 
SQL> alter table sailor add (age number);
b.) Insert values into the sailor table. 
SQL> insert into sailor values(326,’rakhi’,9,21);
c.) Delete the row with rating>8. 
SQL>delete from sailor where rating>8;
d. )Update the column details of sailor.  
SQL>update sailor set sname=’rocky’ where sid=26;
e.)  Insert null values into the table.
SQL> insert into branch values(326,’rakhi’,21);

RESERVES TABLE
SQL> create table reserves(boatid integer,sid integer,day integer);

a.) Insert values into the reserves table.
SQL> insert into branch values(02,026,2);
b.) Add column time to the reserves table.  
SQL> alter table reserves add (time number);
c.) Alter the column day data type todate.  
SQL> alter table reserves rename column day to date;
d.)Drop the column time in the table. 
SQL> alter table reserves drop column time;
e.) Delete the row of the table with some condition.  
SQL> delete from reserves where boatid=20;

-------------------- Week – 2: QUERIES USING DDL AND DML --------------------

1. 
a) create a user and grant all permissions to the user.  
CONNECT <USER-NAME>/<PASSWORD>@<DATABASE NAME>;  
--Create user query  
CREATE USER <USER NAME> IDENTIFIED BY <PASSWORD>;  
--Provide roles  
GRANT CONNECT,RESOURCE,DBA TO <USER NAME>;  
--Assigning privileges  
GRANT CREATE SESSION GRANT ANY PRIVILEGE TO <USER NAME>; 
GRANT UNLIMITED TABLESPACE TO <USER NAME>;  
--Provide access to tables.  
GRANT SELECT, UPDATE, INSERT, DELETE ON <TABLE NAME> TO <USER NAME>; 

b) Insert the any three records in the employee table and use rollback. Check the result.  
SQL> SELECT * FROM EMPLOYEE;
SQL> insert into employee values(105,'aravind','salesman',5678,5000,50);
SQL> rollback;
SQL> SELECT * FROM EMPLOYEE; 

c) Add primary key constraint and not null constraint to the employee table. 
SQL> alter table employee modify(empno number primary key, ename varchar2(10) not null);

d) Insert null values to the employee table and verify the result.
SQL> insert into employee values(105,'mohith','salesman',5678,null,50)

2.
a) create a user and grant all permissions to the user.  
CONNECT <USER-NAME>/<PASSWORD>@<DATABASE NAME>;  
--Create user query  
CREATE USER <USER NAME> IDENTIFIED BY <PASSWORD>;  
--Provide roles  
GRANT CONNECT,RESOURCE,DBA TO <USER NAME>;  
--Assigning privileges  
GRANT CREATE SESSION GRANT ANY PRIVILEGE TO <USER NAME>; 
GRANT UNLIMITED TABLESPACE TO <USER NAME>;  
--Provide access to tables.  
GRANT SELECT, UPDATE, INSERT, DELETE ON <TABLE NAME> TO <USER NAME>; 

b) Insert values in the department table and use commit. 
SQL> insert into department values(13,'sales','delhi')
SQL> commit; 
SQL> select * from department;

c) Add constraints like unique and not null to the department table.  
SQL> alter table department modify(deptno number unique);
SQL> alter table department modify(location varchar2(10) not null);

d) Insert repeated values and null values into the table.
SQL> insert into department values(10,'research','') 
SQL> insert into department values(10,'research','')
SQL> insert into department values(10,'research','hyderabad') 
SQL> insert into department values(10,'research','hyderabad')

3.
a) create a user and grant all permissions to the user.  
CONNECT <USER-NAME>/<PASSWORD>@<DATABASE NAME>;  
--Create user query  
CREATE USER <USER NAME> IDENTIFIED BY <PASSWORD>;  
--Provide roles  
GRANT CONNECT,RESOURCE,DBA TO <USER NAME>;  
--Assigning privileges  
GRANT CREATE SESSION GRANT ANY PRIVILEGE TO <USER NAME>; 
GRANT UNLIMITED TABLESPACE TO <USER NAME>;  
--Provide access to tables.  
GRANT SELECT, UPDATE, INSERT, DELETE ON <TABLE NAME> TO <USER NAME>; 

b.)Insert values in the department table and use commit.
SQL> insert into department values(13,'sales','delhi');
SQL> commit; 

c. Delete Any three records in the department table and use rollback.   
SQL> DELETE FROM employees WHERE emp_sal=10000; 
SQL>ROLLBACK;

d.Add constraint primary key and foreign key to the  table.  
SQL> ALTER TABLE department ADD PRIMARY KEY (location);  
SQL> ALTER TABLE branches ADD FOREIGN KEY (location) REFERENCES department(location);

4.
a) create a user and grant all permissions to the user.  
CONNECT <USER-NAME>/<PASSWORD>@<DATABASE NAME>;  
--Create user query  
CREATE USER <USER NAME> IDENTIFIED BY <PASSWORD>;  
--Provide roles  
GRANT CONNECT,RESOURCE,DBA TO <USER NAME>;  
--Assigning privileges  
GRANT CREATE SESSION GRANT ANY PRIVILEGE TO <USER NAME>; 
GRANT UNLIMITED TABLESPACE TO <USER NAME>;  
--Provide access to tables.  
GRANT SELECT, UPDATE, INSERT, DELETE ON <TABLE NAME> TO <USER NAME>; 

b.)Insert values to the sailor table and use commit.
SQL>insert into sailor values(326,’rakhi’,9,21)  
SQL> commit;

c. Add savepoint after insertion of records and verify savepoint.  
SQL> savepoint week2;    
SQL>rollback to week1;  

d.Add constraints not null and primary key to the sailor table.  
SQL> ALTER TABLE sailor modify sid int NOTNULL;    
SQL> ALTER TABLE sailor ADD PRIMARY KEY (sname);

5.
a) create a user and grant all permissions to the user.  
CONNECT <USER-NAME>/<PASSWORD>@<DATABASE NAME>;  
--Create user query  
CREATE USER <USER NAME> IDENTIFIED BY <PASSWORD>;  
--Provide roles  
GRANT CONNECT,RESOURCE,DBA TO <USER NAME>;  
--Assigning privileges  
GRANT CREATE SESSION GRANT ANY PRIVILEGE TO <USER NAME>; 
GRANT UNLIMITED TABLESPACE TO <USER NAME>;  
--Provide access to tables.  
GRANT SELECT, UPDATE, INSERT, DELETE ON <TABLE NAME> TO <USER NAME>; 

b.Use revoke command to remove user permissions  
SQL>REVOKE UPDATE ON department to  20AK1A3626

c. change password of the user created.  
SQL> ALTER USER C##20AK1A3626@ORCL  IDENTIFIED BY 20AK1A3626

d.add constraint foreign key and not null.    
SQL> ALTER TABLE department modify deptid int NOTNULL;    
SQL> ALTER TABLE branches ADD FOREIGN KEY (location) REFERENCES department(location);

6.
a) create a user and grant all permissions to the user.  
CONNECT <USER-NAME>/<PASSWORD>@<DATABASE NAME>;  
--Create user query  
CREATE USER <USER NAME> IDENTIFIED BY <PASSWORD>;  
--Provide roles  
GRANT CONNECT,RESOURCE,DBA TO <USER NAME>;  
--Assigning privileges  
GRANT CREATE SESSION GRANT ANY PRIVILEGE TO <USER NAME>; 
GRANT UNLIMITED TABLESPACE TO <USER NAME>;  
--Provide access to tables.  
GRANT SELECT, UPDATE, INSERT, DELETE ON <TABLE NAME> TO <USER NAME>; 

b.Update The Table reserves and use savepoint and rollback.  
SQL> update reserves set sid='1' where day=monday;   
SQL> savepoint boats; 
SQL>rollback to boats;

c. Add Constraint primary key,foreign key and not null to the reserves table.  
SQL> ALTER TABLE reserves ADD PRIMARY KEY (sname);    
SQL> ALTER TABLE reserves ADD FOREIGN KEY (sname) REFERENCES boat(sname); 
SQL> ALTER TABLE reserves modify sid int NOTNULL;

d.delete constraint notnull to the table column  
SQL> ALTER TABLE reserves modify (sid int null); 

-------------------- Week – 3: QUERIES USING AGGREGATE FUNCTIONS --------------------

1:  
A) BY USING THE GROUP BY CLAUSE ,DISPALY THE ENAMES WHO BELONGS TO DEPTNO 10 ALONG WITH AVERAGE  
SQL> CREATE TABLE EMP<DEPTNO INT ,ENAME VARCHAR(30), ,SAL INT,DEPTNAME VARCHAR(40);  
SQL> INSERT INTO EMP VALUES (10,'TONY',4000,'ECE'); 
SQL> INSERT INTO EMP VALUES (10,'RAM',2800, 'ECE');  
SQL> INSERT INTO EMP VALUES (10,'TONY',5000,'ECE');
SQL> SELECT * FROM EMP;
SQL> SELECT ENAME, DEPTNO, AVG(SAL)  FROM EMP WHERE DEPTNO=10 GROUP BY ENAME,DEPTNO;

B) DISPLAY LOWEST PAID EMPLOYEE DETAILS ORDER EACH DEPARTMENT  
SQL>INSERT INTO EMP VALUES (12,'SAI',2000, 'CSE');
SQL>INSERT INTO EMP VALUES (12,'SMITH',1000, 'CSE'); 
SQL>INSERT INTO EMP VALUES (12,'TONY',5000, 'CSE');
SQL> SELECT DEPTNAME,MIN(SAL) FROM EMP  GROUP BY DEPTNAME;

C) DISPLAY NUMBER OF EMPLOYEES WORKING IN EACH DEPARTMENT AND THIER DEPT NUMBER  
SQL>SELECT DEPTNO, COUNT(*) FROM EMP GROUP BY DEPTNO;

D) USING BULIT IN FUNCTIONS DISPLAY NUMBER OF EMPLOYEES WORKINGT IN EACH DEPARTMENT AND THERE DEPTNO FROM DEPARTMENT TABLE  
SQL>SELECT DEPTNO,DEPTNAME,COUNT(*) FROM EMP GROUP BY DEPTNO,DEPTNAME;

E) LIST ALL EMPLOYEES STARTS WITH EITHER B OR C  
SQL>INSERT INTO EMP VALUES (12,'BALU',2020, 'CSE');  
SQL>SELECT ENAME FROM EMP WHERE ENAME LIKE 'B%' OR ENAME LIKE 'C%' ORDER BY ENAME;

F) DISPLAY ONLY ENAME OF EMP WHERE MAXIMUM SALARY IS GREATER THAN OR EQUAL TO 5000  
SQL>SELECT ENAME FROM EMP WHERE SAL>=5000;

2: 
A) CALCULATE THE AVERAGE SALARY FOR EACH DIFFERENT JOB.  
SQL> SELECT JOB,AVG(SAL),AVG(SAL+COMMISSION) FROM EMP GROUP BY JOB;

B) SHOW THE AVERAGE SALARY OF EACH JOB EXCLUDING MANAGER.  
SQL> SELECT JOB,AVG(SAL)  FROM EMP WHERE JOB NOT IN('MANAGER') GROUP BY JOB;

C) SHOW THE AVERAGE SALARY FOR ALL DEPARTMENTS EMPLOYING MORE THAN THREE PEOPLE.  
SQL> SELECT DEPTID,AVG(SAL),COUNT(*) FROM EMP GROUP BY DEPTID HAVING COUNT(*)>3;

D) DISPLAY EMPLOYEES WHO EARN MORE THAN THE LOWEST SALARY IN DEPARTMENT 30  
SQL> SELECT ENAME,SAL FROM EMP WHERE DEPTID=30 AND SAL >(SELECT MIN(SAL) FROM EMP WHERE DEPTID=30);

E) SHOW THAT VALUE RETURNED BY SIGN (N) FUNCTION. 
SQL> SELECT SIGN(-15),SIGN(0),SIGN(15) FROM DUAL;

F) HOW MANY DAYS BETWEEN DAY OF BIRTH TO CURRENT DATE.
SQL>DECLARE @START DATETIME 
DECLARE @END DATETIME 
SET @START='2000-10-04' 
SET @END='2021-12-19' 
SELECT DATEDIFF(D,@START,@END);  
SELECT DATEDIFF(D,2000-10-04,2021-12-20);  
 
3:
A. SHOW THAT TWO SUBSTRING AS SINGLE STRING.  
SQL> SELECT CONCAT(CONCAT(ENAME,' '),JOB) AS NAME FROM EMP ORDER BY NAME;

B. LIST ALL EMPLOYEE NAMES, SALARY AND 15% RISE IN SALARY.  
SQL> SELECT EMPNAME,TO_CHAR(1.15*SAL) AS "SAL" FROM EMP;

C. DISPLAY LOWEST PAID EMP DETAILS UNDER EACH MANAGER
SQL> SELECT MGR,MIN(SAL) FROM EMP WHERE MGR IS NOT NULL GROUP BY MGR ORDER BY MIN(SAL) DESC; 
  
D. DISPLAY THE AVERAGE MONTHLY SALARY BILL FOR EACH DEPTNO. 
SQL> SELECT DEPTID,AVG(SAL) AS AVGSAL FROM EMP GROUP BY DEPTID;

E. SHOW THE AVERAGE SALARY FOR ALL DEPARTMENTS EMPLOYING MORE THAN TWO PEOPLE. SELECT JOB,AVG(SAL),COUNT 
SQL> SELECT EMPNO,AVG(SAL),COUNT(EMPNAME)FROM EMP GROUP BY EMPNO HAVING COUNT(EMPNAME)>2;

F. BY USING THE GROUP BY CLAUSE, DISPLAY THE EID WHO BELONGS TO DEPTNO 05 ALONG WITH AVERAGE SALARY  
SQL> SELECT DEPTNO,AVG(SAL) FROM EMP WHERE DEPTNO=12 GROUP BY DEPTNO;

4.
A. COUNT THE NUMBER OF EMPLOYEES IN DEPARTMENT 20 
SQL> SELECT COUNT(EMPNO)FROM EMP WHERE DEPTNO=20;

B. FIND THE MINIMUM SALARY EARNED BY CLERK. 
SQL> SELECT MIN(SAL) FROM EMP WHERE JOB='CLERK';

C. FIND MINIMUM, MAXIMUM, AVERAGE SALARY OF ALL EMPLOYEES.  
SQL> SELECT EMPNO,SUM(SAL),AVG(SAL),MAX(SAL),MIN(SAL) FROM EMP GROUP BY EMPNO;

D. LIST THE MINIMUM AND MAXIMUM SALARIES FOR EACH JOB TYPE.  
SQL> SELECT JOB, MIN(SAL) , MAX(SAL) FROM EMP GROUP BY JOB;

E. LIST THE EMPLOYEE NAMES IN DESCENDING ORDER.  
SQL> SELECT * FROM EMP E ORDER BY E.EMPNAME DESC;

F. LIST THE EMPLOYEE ID, NAMES IN ASCENDING ORDER BY EMPID. 
SQL> SELECT * FROM EMP E ORDER BY E.EMPNAME ASC;

5.
A. FIND THE SIDS ,NAMES OF SAILORS WHO HAVE RESERVED ALL BOATS CALLED “INTERLAKE  
SQL> SELECT * FROM SAILORS WHERE SID IN (SELECT SID FROM RESERVES INNER JOIN BOATS ON RESERVES.BID=BOATS.BID WHERE BOATS.BNMAE='INTERLAKE');

B.FIND THE AGE OF YOUNGEST SAILOR WHO IS ELIGIBLE TO VOTE FOR EACH RATING LEVEL WITH AT LEAST TWO SUCH SAILORS.     
SQL> SELECT S.RATING, MIN(S.AGE) AS MINAGEFROM SAILORS S WHERE S.AGE>18 GROUP BY S.RATING   HAVING COUNT(*) > 1

C. FIND THE SNAME , BID AND RESERVATION DATE FOR EACH RESERVATION.     
SQL> SELECT S.SNAME, R.BID, R.DAY  FROM SAILORS S, RESERVES R  WHERE S.SID = R.SID
 
D. FIND THE AGES OF SAILORS WHOSE NAME BEGIN AND END WITH B AND HAS AT LEAST 3 CHARACTERS.      
SQL> SELECT S.SID,S.AGE FROM SAILORS S WHERE S.SNAME LIKE 'B_%B';

E. LIST IN ALPHABETIC ORDER ALL SAILORS WHO HAVE RESERVED RED BOAT.      
SQL>SELECT S.NAME, S.AGE FROM SAILORS S, RESERVES R, BOATS B WHERE S.ID = R.SID AND R.BID = B.ID AND B.COLOR = 'RED' ORDER BY S.NAME;

F. FIND THE AGE OF YOUNGEST SAILOR FOR EACH RATING LEVEL.       
SQL> SELECT S.RATING, MIN (S.AGE)  FROM SAILORS S GROUP BY S.RATING 

-------------------- Week – 4: PROGRAMS ON PL/SQL --------------------

1 a) Write a PL/SQL block to find the maximum number from given three numbers. 
declare a number; 
b number; 
c number; 
begin 
a:=10; 
b:=20; 
c:=30; 
if (a>b and a>c) then 
dbms_output.put_line('a is maximum ' || a); 
elsif (b>a and b>c) then 
dbms_output.put_line('b is maximum ' || b); 
else
dbms_output.put_line('c is maximum ' || c);  
end if; 
end; 
/

1b) write a PL/SQL program for swapping 2 numbers. 
declare a number(3); 
b number(3); 
begin 
a:=&a; 
b:=&b; 
dbms_output.put_line(‘Before swapping a= ‘||a||’ and b= ‘||b); 
a:=a+b; 
b:=a-b; 
a:=a-b; 
dbms_output.put_line(‘After swapping a= ‘||a||’ and b= ‘||b); 
end; 
/ 

2 a) Write a PL/SQL program to find the total and average of 4 subjects and display the grade 
declare 
java number(10); 
dbms number(10); 
co number(10); 
mfcs number(10); 
total number(10); 
avgs number(10); 
per number(10); 
begin 
java:=100; 
dbms:=100; 
co:=100; 
mfcs:=100; 
total:=(java+dbms+co+mfcs); 
per:=(total/600)*100; 
if java<40 or dbms<40 or co<40 or mfcs<40 then 
dbms_output.put_line('FAIL'); 
if per>75 then 
dbms_output.put_line('GRADE A'); 
elsif per>65 and per<75 then 
dbms_output.put_line('GRADE B'); 
elsif per>55 and per<65 then 
dbms_output.put_line('GRADE C'); 
else 
dbms_output.put_line('INVALID INPUT'); 
end if; 
dbms_output.put_line('PERCENTAGE IS '||per); 
end; 
/

2 b) Write a program to accept a number and find the sum of the digits  
declare 
n number(5):=&n; 
s number:=0; 
r number(2):=0; 
begin 
while n !=0 
loop 
r:=mod(n,10); 
s:=s+r; 
n:=trunc(n/10); 
end loop; 
dbms_output.put_line('sum of digits of given number is '||s); 
end; 
/

3 a) PL/SQL Program to accept a number from user and print number in reverse order. 
declare 
num1 number(5); 
num2 number(5); 
rev number(5); 
begin num1:=&num1; 
rev:=0; 
while num1>0 
loop 
num2:=num1 mod 10; 
rev:=num2+(rev*10); 
num1:=floor(num1/10); 
end loop; 
dbms_output.put_line('Reverse number is: '||rev); 
end; 
/

3b) Write a PL / SQL program to check whether the given number is prime or not. 
declare 
num number;  
i number:=1; 
c number:=0; 
begin 
num:=&num; 
for i in 1..num 
loop 
if((mod(num,i))=0) then 
c:=c+1; end if;
end loop; 
if(c>2) then 
dbms_output.put_line(num||' not a prime'); 
else 
dbms_output.put_line(num||' is prime'); 
end if; 
end; 
/ 

4 a) Write a PL/SQL program to find the factorial of a given number. 
declare 
i number(4):=1; 
n number(4):=&n; 
f number(4):=1; 
begin 
for i in 1..n 
loop 
f:=f*i; 
end loop; 
dbms_output.put_line('the factorial of '||n||' is:'||f); 
end; 
/

4 b) calculate the area of a circle for a value of radius varying from 3 to 7. Store the radius and the corresponding values of  calculated area in  table areas.  Consisting of two columns  radius and area 
create table areas ( r number(2), area number (14,2));  
declare 
r number(5); 
area number(14,2); 
pi constant number (4,2):=3.14; 
begin 
r:=3; 
while r<=7 
loop 
area:=pi*power(r,2); 
insert into areas values(r,area ); 
r:=r+1; 
end loop; 
end; 
/ 
select * from areas;

5a) Write a PL/SQL program to accept a string and remove the vowels from the string. (When ‘hello’ passed to the program it should display ‘Hll’ removing e and o from the world Hello). 
set serveroutput on 
set verify off  
accept vstring prompt "Please enter your string: "; 
declare    
vnewstring varchar2(100); 
begin    
vnewstring := regexp_replace('&vstring', '[aeiouAEIOU]','');    
dbms_output.put_line('The new string is: ' || vnewstring); 
end; 
/ 

5 b) Write a PL/SQL program to accept a number and a divisor. Make sure the divisor is less than or equal to 10. Else display an error message. Otherwise Display the remainder.  
select remainder(37,5) "remainder" from dual ;  

-------------------- Week – 5: PROCEDURES AND FUNCTIONS --------------------

1) Write a function to accept employee number as parameter and return Basic +HRA together as single column.  
SQL> create or replace function empno(empno number basic number hra number) 
return number is 
begin 
return sal+hra; 
end empno; 
/

2.)Accept year as parameter and write a Function to return the total net salary spent for a given year.  
SQL> create or replace function totalsalary  
return number is     
totalsal number(2) := 0;  
begin     
select sum(sal) into      
from customers;          
return total;  
end;  
/ 

3.)Create a function to find the factorial of a given number and hence find NCR.  
SQL> create or replace function fact(n number)  
return number is  
a number:=n;  
f number:=1;  
i number;  
begin  
for i in 1..n  
loop  
f:=f*a;  
a:=a-1;  
end loop;  
return f;  
end;  
/
SQL> select fact(2) from dual;

SQL> create or replace function ncr(n number ,r number)  
return number is  
n1 number:=fact(n);  
r1 number:=fact(r);  
nr1 number:=fact(n-r);  
result number;  
begin  
result:=(n1)/(r1*nr1);  
return result;  
end;  
/
SQL> select ncr(5,2) from dual;

4.)Write a PL/SQL block To pint prime Fibonacci series using local functions.  
SQL> create or replace function fib (n positive) 
return integer is  
begin  
if (n = 1) or (n = 2) then  
return 1;  
else  
return fib(n - 1) + fib(n - 2);   
end if;  
end fib;  
SQL>SELECT fib(2), fib(3), fib(4), fib(5) FROM dual; 

5.) Create a procedure to find the lucky number of a given birth date..   
SQL> set serverout on 
SQL> declare 
l_input varchar2(20) := '04/10/2000'; 
l_output int; 
begin 
loop 
dbms_output.put_line(' ----------------- '); 
dbms_output.put_line('l_input='||l_input); l_output := 0; 
for i in 1 .. length(l_input) 
loop 
if substr(l_input,i,1) between '0' and '9' then 
l_output := l_output + to_number(substr(l_input,i,1)); 
end if; 
end loop; 
dbms_output.put_line('l_output='||l_output); 
exit when l_output < 10; l_input := to_char(l_output); 
end loop; 
dbms_output.put_line(' ----------------- '); 
dbms_output.put_line('Lucky='||l_output); 
end; 
/

6.) Create function to the reverse of given number.   
SQL>  create or replace function reverse(num in number,)     
return number is      
rev number;     
begin     
while(num>0) 
Loop 
rev=rev*10+mod(num,10); 
num=num/10; 
End loop; 
Dbms_Output.Put_Line("Reverse of number is '|| rev);  
return rev;     
end;     
/

-------------------- Week – 6: TRIGGERS --------------------

1.) Create a row level trigger for the customers table that would fire for INSERT or UPDATE or DELETE operations performed on the CUSTOMERS table. This trigger will display the salary difference between the old values and new values:
SQL> CREATE OR REPLACE TRIGGER display_salary_changes  
BEFORE DELETE OR INSERT OR UPDATE ON customers FOR EACH ROW 
WHEN (NEW.ID > 0)  
DECLARE sal_diff number;  
BEGIN 
sal_diff := :NEW.salary - :OLD.salary;  
dbms_output.put_line('Old salary: ' || :OLD.salary);  
dbms_output.put_line('New salary: ' || :NEW.salary);  
dbms_output.put_line('Salary difference: ' || sal_diff); 
END; 
/
SQL> INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) VALUES (7, 'Kriti', 22, 'HP', 7500.00 );
SQL>UPDATE CUSTOMERS SET salary =8000 where id=7; 

2.) Creation of insert trigger, delete trigger, update trigger practice trigger using the passenger database.  
SQL> CREATE TABLE Passenger ( P_ID  INTEGER PRIMARY KEY, NAME VARCHAR(50) NOT NULL, AGE INTEGER NOT NULL, SEX CHAR, ADDR VARCHAR(50) NOT NULL);
A. Write a insert trigger to check the passport id is exactly 6-digits or not. 
SET SERVEROUTPUT ON 
CREATE OR REPLACE TRIGGER Pass_ID 
BEFORE INSERT ON Passenger FOR EACH ROW 
DECLARE C NUMBER; 
Pass_ID NUMBER:=:NEW.Pass_ID; 
BEGIN 
C:=(LENGTH(Pass_ID)); 
IF(C=6) THEN 
DBMS_OUTPUT.PUT_LINE('TRIGGER FIRED'); 
END IF; 
END; 
/
SQL> INSERT INTO Passenger VALUES(135791,'POOJITHA',20,'F','CHITTOOR');

4.)Convert  employee  name  into  uppercase whenever  an  employee  record  is  inserted  or updated. Trigger to fire before the insert or update.   
SQL> CREATE OR REPLACE TRIGGER employee_insert_update 
BEFORE INSERT OR UPDATE ON employee FOR EACH ROW  
DECLARE dup_flag INTEGER;  
BEGIN  
NEW.first_name := UPPER(:NEW.first_name); 
END;  
/ 
SQL> insert into Employee(ID,  First_Name, Last_Name, Start_Date,  End_Date,  Salary,  City, Description) values ('01','Jason',  'Martin', to_date('19960725','YYYYMMDD'), to_date('20060725','YYYYMMDD'), 1234.56, 'Toronto', 'Programmer') 

5.Trigger before deleting a record from emp table. Trigger will insert the row to be deleted into table called delete _emp and also record user who has deleted the record and date and time of delete.
SQL>  CREATE OR REPLACE TRIGGER employee_before_delete 
BEFORE DELETE ON employee FOR EACH ROW 
DECLARE 
v_username varchar2(10); 
BEGIN  
SELECT user INTO v_username 10 FROM dual; 
INSERT INTO employee_audit (id, salary, delete_date,deleted_by) VALUES (:old.id,:old.salary, sysdate, v_username ); 
END;  
/
SQL> delete from employee;

-------------------- Week – 7: PROCEDURES --------------------

1. Create the procedure for palindrome of given number.     
create or replace procedure palindrome(str in varchar2) as   
len number:=0;   
cnt number :=0;   
j number :=0;   
begin   
len := length(str);   
for i in 1..len 
loop   
j := i-1;   
if substr(str,i,1) = substr(str,len-j,1) then   
cnt := cnt+1;   
end if;   
end loop;   
if cnt = len then  
dbms_output.put_line('it is palindrome');   
else   
dbms_output.put_line('it is not palindrome');   
end if;   
end;   
/
SQL> exec palindrome('123');

2. Create the procedure for GCD: Program should load two registers with two Numbers and then  apply  the  logic  for  GCD  of  two  numbers.  GCD  of  two  numbers  is  performed  by dividing the greater number by the smaller number till the remainder is zero. If it is zero, the divisor is the GCD if not the remainder and the divisors of the previous division are the  new  set  of  two  numbers.  The  process  is  repeated  by  dividing  greater  of  the  two numbers by the smaller number till the remainder is zero and GCD is found. 
SQL> create or replace procedure gcd(x in integer,y in integer,ans out integer) as       
begin          
if (y <= x) and (x mod y = 0) then              
ans := y;           
elsif x < y then               
gcd(y, x, ans);            
else             
gcd(y, x mod y, ans);           
end if;          
return;    
end gcd;    
/
SQL> var v number 
SQL> exec gcd(24,18, :v);
SQL> print v;

3. Write the PL/SQL programs to create the procedure for factorial of given number.
SQL> create or replace procedure factorial(n in number) as 
r number :=1; 
begin 
for i in  1..n 
loop 
r :=r * i; 
end loop; 
dbms_output.put_line(r); 
end; 
/
SQL> exec factorial(5);

4. Write the PL/SQL programs to create the procedure to find sum of N natural number.  
SQL> create or replace procedure sumn(n in number) as 
g number :=0; 
begin 
for i in  1..n 
loop 
g :=g + i; 
end loop; 
dbms_output.put_line(g); 
end; 
/
SQL> exec sumn(11);

5. Write the PL/SQL program to create the procedure to find Fibonacci series.
SQL> CREATE OR REPLACE procedure fib(n number)is 
num1 number := 0; 
num2 number := 1; 
num3 number; 
cnt number default 0;
t number; 
begin dbms_output.put_line(num1); 
dbms_output.put_line(num2); 
while cnt!= n-2 
loop 
num3:=num1+num2; 
dbms_output.put_line(num3); 
t:=num2; 
num2:=num3; 
num1:=t; 
cnt:=cnt+1; 
end loop; 
exception when others then 
dbms_output.put_line(sqlerrm); 
end; 
/
SQL> exec fib(11);

6. Write the PL/SQL programs to create the procedure to check the given number is perfect or  not. 
create or replace procedure perfect(n number) as 
i number; 
total number; 
begin 
total :=0; 
for i in 1..n/2 
loop 
if(n mod i=0) then 
total:= total+i; 
end if; 
end loop; 
if(n=total)then 
dbms_output.put_line('Yes It is a Perfect Number'); 
else 
dbms_output.put_line('It is Not a Perfect Number'); 
end if; 
end; 
/
SQL> exec perfect(11); 

-------------------- Week – 8: CURSORS --------------------

1.) Write a PL/SQL  block that will display the name, dept no, salary of fist highest paid  employees.
SQL> DECLARE    
s_deptno dept.deptno%type;    
s_deptname dept.deptname%type;    
s_salary dept.salary%type;    
CURSOR cur_dept is       
SELECT deptno, deptname, salary from dept where salary>12000; 
BEGIN    
OPEN cur_dept;    
LOOP       
FETCH cur_dept into s_deptno, s_deptname, s_salary;       
EXIT WHEN cur_dept%notfound;       
dbms_output.put_line(s_deptno || ' ' || s_deptname || ' ' || s_salary);    
END LOOP;    
CLOSE cur_dept; 
END; 
/

2.Update the balance stock in the item master table each time a transaction takes place in the item transaction table. The change in item master table depends on the item id is already present in the  item master then update operation is performed to decrease the balance stock by the quantity specified in the item transaction in case the item id is not present in the item master table then the record is inserted in the item master table. 
SQL> create table item_master(item_id number,balance_stock varchar2(20),transact ion varchar2(20)); 
SQL> desc item_master
SQL> select * from item_master;
SQL> DECLARE  var_rows number(2);   
BEGIN   
insert into item_master values(6,125,63);   
UPDATE item_master   
SET balance_stock = balance_stock-23 where item_id=6;   
IF SQL%NOTFOUND THEN   
dbms_output.put_line('No record updated.');   
ELSIF SQL%FOUND THEN   
var_rows := SQL%ROWCOUNT;  
dbms_output.put_line(var_rows || ' employees are updated.');  
END IF;  
END;  
/
SQL> select * from item_master; 

3.)Write a PL/SQL block that will display the employee details along with salary using cursors.
DECLARE    
s_empno emph.empno%type;    
s_empname emph.empname%type;    
s_job emph.job%type;    
s_mgr emph.mgr%type;    
s_sal emph.sal%type;    
s_commission emph.commission%type;    
s_deptname emph.deptname%type;    
CURSOR cur_emph is       
SELECT * from emph; 
BEGIN    
OPEN cur_emph;    
LOOP       
FETCH cur_emph into s_empno, s_empname, s_job, s_mgr, s_sal, s_commission, s_deptname;       
EXIT WHEN cur_emph%notfound;       
dbms_output.put_line(s_empno || ' ' || s_empname || ' ' || s_job|| ' ' ||s_mgr|| ' ' || s_sal|| ' ' || s_commission|| ' ' || s_deptname);    
END LOOP;    
CLOSE cur_emph; 
END; 
/

4.)To write a Cursor to display the list of employees who are working as a Managers or Analyst.
DECLARE    
s_empno emph.empno%type;    
s_empname emph.empname%type;    
s_job emph.job%type;    
s_mgr emph.mgr%type;    
s_sal emph.sal%type;    
s_commission emph.commission%type;    
s_deptname emph.deptname%type;    
CURSOR cur_emph is       
SELECT * from emph where job='manager' or job='analyst'; 
BEGIN    
OPEN cur_emph;    
LOOP       
FETCH cur_emph into s_empno, s_empname, s_job, s_mgr, s_sal, s_commission, s_deptname;       
EXIT WHEN cur_emph%notfound;       
dbms_output.put_line(s_empno || ' ' || s_empname || ' ' || s_job|| ' ' ||s_mgr|| ' ' || s_sal|| ' ' || s_commission|| ' ' || s_deptname);    
END LOOP;    
CLOSE cur_emph; 
END; 
/
5.)To write a Cursor to find employee with given job and deptno.
DECLARE    
s_empno emph.empno%type:=&enter_empno;    
s_empname emph.empname%type;    
s_job emph.job%type:='&enter_job';    
s_mgr emph.mgr%type;    
s_sal emph.sal%type;    
s_commission emph.commission%type;    
s_deptname emph.deptname%type;    
CURSOR cur_emph is       
SELECT * from emph where  empno=s_empno and job=s_job; 
BEGIN    
OPEN cur_emph;    
LOOP       
FETCH cur_emph into s_empno,s_empname,s_job,s_mgr,s_sal,s_commission,s_deptname;       EXIT WHEN cur_emph%notfound;       dbms_output.put_line(s_empno|| ' ' ||s_empname|| ' ' ||s_job|| ' ' ||s_mgr|| ' ' ||s_sal|| ' ' ||s_commission|| ' ' ||s_deptname);    
END LOOP; 
CLOSE cur_emph; 
END; 
/ 

6.)Write a PL/SQL block using implicit cursor that will display message, the salaries of all the employees in the ‘employee’ table are updated. If none of the employee’s salary are updated we get a message 'None of the salaries were updated'. Else we get a message like for example, 'Salaries for 1000 employees are updated' if there are 1000 rows in ‘employee’ table 
SQL> DECLARE  var_rows number(2); 
BEGIN   
UPDATE employees    
SET salary = salary + 2000;   
IF SQL%NOTFOUND THEN     
dbms_output.put_line('None of  the salaries were updated');  
ELSIF SQL%FOUND THEN     
var_rows := SQL%ROWCOUNT;     
dbms_output.put_line(var_rows || ' employees are updated.');   
END IF;  
END; 
/
 </pre>
